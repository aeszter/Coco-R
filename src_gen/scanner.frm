-------------------------------------------------
--                                             --
--       Scanner generated by Coco/R           --
--                                             --
-- (assuming FileIO library will be available) --
-------------------------------------------------

with FileIO;

package body -->modulename is


   noSYMB  : constant := -->unknownsym;  -- error token code
   -- not only for errors but also for not finished states of scanner analysis
   EOF     : constant Character := FileIO.EOF;
   EOL     : constant Character := FileIO.CR;
   CR      : constant Character := FileIO.CR;
   LF      : constant Character := FileIO.LF;
   BlkSize : constant := 16384;



   subtype  BufBlock       is String (1 .. (BlkSize));
   type     BufBlock_Ptr   is access BufBlock;

   type     Buffer         is array (Integer range 0 .. 31) of BufBlock_Ptr;
   type     StartTable     is array (Integer range 0 .. 255) of Integer;

   type     GetCH          is access function (pos: in     INT32) return Character;



   lastCh      : Character;
   ch          : Character;   -- current input character
   curLine     : Integer;     -- current input line (may be higher than line)
   lineStart   : INT32;       -- start position of current line
   apx         : INT32;       -- length of appendix (CONTEXT phrase)
   oldEols     : Integer;     -- number of EOLs in a comment

   bp          : INT32;       -- current position in buf
   bp0         : INT32;       -- position of current token

   LBlkSize    : INT32;       -- BlkSize
   inputLen    : INT32;       -- source file size

   buf         : Buffer;      -- source buffer for low-level access
   start       : StartTable;  -- start state for every character
   Current_Ch  : GetCH;



   function ORDL (n: in     INT32) return CARDINAL renames FileIO.ORDL;


   procedure Err
     (nr    : in     Integer;
      line  : in     Integer;
      col   : in     Integer;
      pos   : in     INT32)
   is
   begin
      errors := errors + 1;
   end Err;


   --
   -- Return global variable ch
   --
   procedure Next_Ch
   is
   begin
      lastCh := ch;
      bp := bp + 1;
      ch := Current_Ch (bp);
      if  (ch = EOL) or else ((ch = FileIO.LF) and then (lastCh /= EOL))  then
         curLine := curLine + 1;
         lineStart := bp;
      end if;
   end Next_Ch;


   function Comment return Boolean
   is
      level       : Integer;
      startLine   : Integer;
      oldLineStart: INT32;
   begin
      level        := 1;
      startLine    := curLine;
      oldLineStart := lineStart;
      -->comment
      return FALSE;
   end Comment;


   --
   -- Gets next symbol from source file
   --
   procedure Get (sym:    out CARDINAL)
   is

      state: CARDINAL;

      function Equal (S: in     String) return Boolean
      is
         I: CARDINAL;
         q: INT32;
      begin
         if  nextLen /= FileIO.SLENGTH (S)  then
            return FALSE;
         end if;

         I := S'First + 1;
         q := bp0 + 1;

         while  I <= nextLen  loop
            if  Current_Ch (q) /= S (I)  then
               return FALSE;
            end if;
            I := I + 1;
            q := q + 1;
         end loop;

         return TRUE;
      end Equal;

      procedure Check_Literal
      is
      begin
         -->literals
      end Check_Literal;

   begin -- Get
      -->GetSy1

      pos      := nextPos;   
      nextPos  := bp;
      col      := nextCol;   
      nextCol  := FileIO.INTL (bp - lineStart);
      line     := nextLine; 
      nextLine := curLine;
      len      := nextLen;   
      nextLen  := 0;
--       apx      := 0; 
      state    := start (Character'Pos (ch)); 
      bp0      := bp;

      loop
         Next_Ch; 
         nextLen := nextLen + 1;
         case  state  is
            -->GetSy2
            when others =>    -- Next_Ch already done
               sym := noSYMB;
               return;
         end case;
      end loop;
   end Get;


   --
   -- Retrieves exact The_String of max The_Length from The_Position in source file
   --
   procedure Get_String
     (The_Position   : in     INT32;
      The_Length     : in     CARDINAL;
      The_String     :    out FileIO.String_Ptr)
   is
   begin
      if  The_Length <= 0  then 
         The_String := null;
      else
         declare
            S : String (1..The_Length);
            P : INT32;         
         begin
            P := The_Position;
            for  I in S'Range  loop
               S (I) := Char_At (P); 
               P     := P + 1;
            end loop;
            The_String := new String'(S);
         end;
      end if;
   end Get_String;

   --
   -- Retrieves The_Name of symbol of The_Length at The_Position in source file
   --
   procedure Get_Name
     (The_Position   : in     INT32;
      The_Length     : in     CARDINAL;
      The_Name       :    out FileIO.String_Ptr)
   is
   begin
      if  The_Length <= 0  then 
         The_Name := null;
      else
         declare
            S : String (1..The_Length);         
            P : INT32;         
         begin
            P := The_Position;
            for  I in S'Range  loop
               S (I) := Current_Ch (P); 
               P     := P + 1;
            end loop;
            The_Name := new String'(S);
         end;
      end if;
   end Get_Name;


   --
   -- Returns exact character at position pos in source file
   --
   function Char_At (The_Position: in     INT32) return Character
   is
      C : Character;
   begin
      if  The_Position >= inputLen  then 
         return FileIO.EOF;
      end if;

      C := buf (ORDL (The_Position / LBlkSize))
               (ORDL ((The_Position mod LBlkSize)) + 1);

      if  C /= eof  then 
         return C;
      else 
         return FileIO.EOF;
      end if;
   end Char_At;


   function Up_Char_At (The_Position: in     INT32) return Character
   is
      C : Character;
   begin
      if  The_Position >= inputLen  then 
         return FileIO.EOF;
      end if;

      C := FileIO.Up_Case
            (buf (ORDL (The_Position / LBlkSize))
                 (ORDL (The_Position mod LBlkSize) + 1));

      if  C /= eof  then 
         return C ;
      else 
         return FileIO.EOF;
      end if;
   end Up_Char_At;


   --
   -- Reads and stores source file internally
   --
   procedure Reset
   is
      len   : INT32;
      I     : CARDINAL;
      read  : CARDINAL;
   begin -- assert: Source has been opened
      inputLen := FileIO.Length (Source); -- save Length of source

      I        := 0; 
      len      := inputLen;
      while  len > LBlkSize  loop
         buf (I) := new BufBlock;
         read    := BlkSize;
         FileIO.Read_Bytes (Source, buf (I).all, read);
         len := len - FileIO.INT (read); 
         I := I + 1;
      end loop;

      buf (I) := new BufBlock;
      read := ORDL (len); 
      FileIO.Read_Bytes (Source, buf (I).all, read);
      buf (I) (read) := EOF;

      curLine   := 1; 
      lineStart := -2;
      bp        := -1;
      oldEols   := 0; 
      apx       := 0;
      errors    := 0;

      Next_Ch;
   end Reset;


begin
   -->initializations

   Error    := Err'Access; 
   LBlkSize := FileIO.INT (BlkSize);
   lastCh   := EOF;
end -->modulename;


-------------------------------------------------
--                                             -- 
--       Scanner generated by Coco/R           --
--                                             -- 
-- (assuming FileIO library will be available) --
-------------------------------------------------

with FileIO;

package -->modulename is


   subtype INT32     is FileIO.INT32;
   subtype CARDINAL  is FileIO.CARDINAL;


   Source   : aliased FileIO.File;  -- source/list files. To be opened by the main pgm
   Listing  : aliased FileIO.File;

   directory :  String (1 .. 256);   -- of source file

   line     :  Integer;    -- line and column of current symbol
   col      :  Integer;

   len      :  CARDINAL;   -- length of current symbol
   pos      :  INT32;      -- file position of current symbol
   nextLine :  Integer;    -- line of lookahead symbol
   nextCol  :  Integer;    -- column of lookahead symbol
   nextLen  :  CARDINAL;   -- length of lookahead symbol
   nextPos  :  INT32;      -- file position of lookahead symbol
   errors   :  Integer;    -- number of detected errors


   type Error_Procedure is access
      procedure
        (nr    : in     Integer;
         line  : in     Integer;
         col   : in     Integer;
         pos   : in     INT32);

   Error    : Error_Procedure;



   --
   -- Gets next symbol from source file 
   --
   procedure Get (sym:    out CARDINAL);

   --
   -- Retrieves exact The_String of max The_Length from The_Position in source file
   --
   procedure Get_String
     (The_Position   : in     INT32;
      The_Length     : in     CARDINAL;
      The_String     :    out FileIO.String_Ptr);

   --
   -- Retrieves The_Name of symbol of The_Length at The_Position in source file
   --
   procedure Get_Name
     (The_Position   : in     INT32;
      The_Length     : in     CARDINAL;
      The_Name       :    out FileIO.String_Ptr);

   --
   -- Returns exact character at position pos in source file 
   --
   function Char_At (The_Position: in     INT32) return Character;

   --
   -- Reads and stores source file internally 
   --
   procedure Reset;

end -->modulename;







